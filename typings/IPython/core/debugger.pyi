"""
This type stub file was generated by pyright.
"""

from IPython.testing.skipdoctest import skip_doctest
from pdb import Pdb as OldPdb

"""
Pdb debugger class.

Modified from the standard pdb.Pdb class to avoid including readline, so that
the command line completion of other programs which include this isn't
damaged.

In the future, this class will be expanded with improvements over the standard
pdb.

The code in this file is mainly lifted out of cmd.py in Python 2.2, with minor
changes. Licensing should therefore be under the standard Python terms.  For
details on the PSF (Python Software Foundation) standard license, see:

https://docs.python.org/2/license.html
"""
prompt = ...
def make_arrow(pad): # -> Literal['>', '']:
    """generate the leading arrow in front of traceback or debugger"""
    ...

def BdbQuit_excepthook(et, ev, tb, excepthook=...): # -> None:
    """Exception hook which handles `BdbQuit` exceptions.

    All other exceptions are processed using the `excepthook`
    parameter.
    """
    ...

def BdbQuit_IPython_excepthook(self, et, ev, tb, tb_offset=...): # -> None:
    ...

class Tracer:
    """
    DEPRECATED

    Class for local debugging, similar to pdb.set_trace.

    Instances of this class, when called, behave like pdb.set_trace, but
    providing IPython's enhanced capabilities.

    This is implemented as a class which must be initialized in your own code
    and not as a standalone function because we need to detect at runtime
    whether IPython is already active or not.  That detection is done in the
    constructor, ensuring that this code plays nicely with a running IPython,
    while functioning acceptably (though with limitations) if outside of it.
    """
    @skip_doctest
    def __init__(self, colors=...) -> None:
        """
        DEPRECATED

        Create a local debugger instance.

        Parameters
        ----------

        colors : str, optional
            The name of the color scheme to use, it must be one of IPython's
            valid color schemes.  If not given, the function will default to
            the current IPython scheme when running inside IPython, and to
            'NoColor' otherwise.

        Examples
        --------
        ::

            from IPython.core.debugger import Tracer; debug_here = Tracer()

        Later in your code::

            debug_here()  # -> will open up the debugger at that point.

        Once the debugger activates, you can use all of its regular commands to
        step through code, set breakpoints, etc.  See the pdb documentation
        from the Python standard library for usage details.
        """
        ...
    
    def __call__(self): # -> None:
        """Starts an interactive debugger at the point where called.

        This is similar to the pdb.set_trace() function from the std lib, but
        using IPython's enhanced debugger."""
        ...
    


RGX_EXTRA_INDENT = ...
def strip_indentation(multiline_string): # -> str:
    ...

def decorate_fn_with_doc(new_fn, old_fn, additional_text=...): # -> (*args: Unknown, **kw: Unknown) -> Unknown:
    """Make new_fn have old_fn's doc string. This is particularly useful
    for the ``do_...`` commands that hook into the help system.
    Adapted from from a comp.lang.python posting
    by Duncan Booth."""
    ...

class Pdb(OldPdb):
    """Modified Pdb class, does not load readline.

    for a standalone version that uses prompt_toolkit, see
    `IPython.terminal.debugger.TerminalPdb` and
    `IPython.terminal.debugger.set_trace()`
    """
    def __init__(self, color_scheme=..., completekey=..., stdin=..., stdout=..., context=..., **kwargs) -> None:
        """Create a new IPython debugger.
        
        :param color_scheme: Deprecated, do not use.
        :param completekey: Passed to pdb.Pdb.
        :param stdin: Passed to pdb.Pdb.
        :param stdout: Passed to pdb.Pdb.
        :param context: Number of lines of source code context to show when
            displaying stacktrace information.
        :param kwargs: Passed to pdb.Pdb.
            The possibilities are python version dependent, see the python
            docs for more info.
        """
        ...
    
    def set_colors(self, scheme): # -> None:
        """Shorthand access to the color table scheme selector method."""
        ...
    
    def set_trace(self, frame=...): # -> None:
        ...
    
    def hidden_frames(self, stack): # -> list[Unknown | bool]:
        """
        Given an index in the stack return wether it should be skipped.

        This is used in up/down and where to skip frames.
        """
        ...
    
    def interaction(self, frame, traceback): # -> None:
        ...
    
    def new_do_frame(self, arg): # -> None:
        ...
    
    def new_do_quit(self, arg): # -> bool | None:
        ...
    
    do_q = ...
    def new_do_restart(self, arg): # -> bool | None:
        """Restart command. In the context of ipython this is exactly the same
        thing as 'quit'."""
        ...
    
    def print_stack_trace(self, context=...): # -> None:
        ...
    
    def print_stack_entry(self, frame_lineno, prompt_prefix=..., context=...): # -> None:
        ...
    
    def format_stack_entry(self, frame_lineno, lprefix=..., context=...): # -> str:
        ...
    
    def print_list_lines(self, filename, first, last): # -> None:
        """The printing (as opposed to the parsing part of a 'list'
        command."""
        ...
    
    def do_skip_hidden(self, arg): # -> None:
        """
        Change whether or not we should skip frames with the
        __tracebackhide__ attribute.
        """
        ...
    
    def do_list(self, arg): # -> None:
        """Print lines of code from the current stack frame
        """
        ...
    
    do_l = ...
    def getsourcelines(self, obj): # -> tuple[list[str], Literal[1]] | tuple[Sequence[str], int]:
        ...
    
    def do_longlist(self, arg): # -> None:
        """Print lines of code from the current stack frame.

        Shows more lines than 'list' does.
        """
        ...
    
    do_ll = ...
    def do_debug(self, arg): # -> None:
        """debug code
        Enter a recursive debugger that steps through the code
        argument (which is an arbitrary expression or statement to be
        executed in the current environment).
        """
        ...
    
    def do_pdef(self, arg): # -> None:
        """Print the call signature for any callable object.

        The debugger interface to %pdef"""
        ...
    
    def do_pdoc(self, arg): # -> None:
        """Print the docstring for an object.

        The debugger interface to %pdoc."""
        ...
    
    def do_pfile(self, arg): # -> None:
        """Print (or run through pager) the file where an object is defined.

        The debugger interface to %pfile.
        """
        ...
    
    def do_pinfo(self, arg): # -> None:
        """Provide detailed information about an object.

        The debugger interface to %pinfo, i.e., obj?."""
        ...
    
    def do_pinfo2(self, arg): # -> None:
        """Provide extra detailed information about an object.

        The debugger interface to %pinfo2, i.e., obj??."""
        ...
    
    def do_psource(self, arg): # -> None:
        """Print (or run through pager) the source code for an object."""
        ...
    
    def do_where(self, arg): # -> None:
        """w(here)
        Print a stack trace, with the most recent frame at the bottom.
        An arrow indicates the "current frame", which determines the
        context of most commands. 'bt' is an alias for this command.

        Take a number as argument as an (optional) number of context line to
        print"""
        ...
    
    do_w = ...
    def stop_here(self, frame): # -> bool:
        """Check if pdb should stop here"""
        ...
    
    def do_up(self, arg): # -> None:
        """u(p) [count]
        Move the current frame count (default one) levels up in the
        stack trace (to an older frame).

        Will skip hidden frames.
        """
        ...
    
    def do_down(self, arg): # -> None:
        """d(own) [count]
        Move the current frame count (default one) levels down in the
        stack trace (to a newer frame).

        Will skip hidden frames.
        """
        ...
    
    do_d = ...
    do_u = ...
    def do_context(self, context): # -> None:
        """context number_of_lines
        Set the number of lines of source code to show when displaying
        stacktrace information.
        """
        ...
    


class InterruptiblePdb(Pdb):
    """Version of debugger where KeyboardInterrupt exits the debugger altogether."""
    def cmdloop(self): # -> None:
        """Wrap cmdloop() such that KeyboardInterrupt stops the debugger."""
        ...
    


def set_trace(frame=...): # -> None:
    """
    Start debugging from `frame`.

    If frame is not specified, debugging starts from caller's frame.
    """
    ...

